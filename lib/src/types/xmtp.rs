//! XMTP Extensions to the did:ethr specification
//!
//! The XMTP Extension to the did:ethr specification allows for the creation of
//! XMTP-specific DIDs as did:ethr attributes. The format is:
//!
//! "xmtp/(installation_key)/(hex|base64|base58)"
//!
//!
//! * `installation_key` adds a verification key to the `verificationMethod` section of the
//! document and adds a reference to it in the `authentication` section. It also adds a
//! `meta=installation` query to the DidUrl ID of the verification method and therefore the
//! authentication reference.
//!
//! *_NOTE:_* This format may be updated and changed according to the needs of the XMTP protocol. (currently
//! in development)

use super::{Attribute, EthrBuilder, KeyEncoding, KeyType, VerificationMethod};
use crate::error::EthrBuilderError;

use std::fmt;

use serde::{Deserialize, Serialize};

/// The XMTP Attribute Type
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
pub struct XmtpAttribute {
    /// The purpose of the key, e.g installation
    pub purpose: XmtpKeyPurpose,
    /// the encoding of the key, e.g hex or base64
    pub encoding: KeyEncoding,
}

impl fmt::Display for XmtpAttribute {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "xmtp/{}/{}", self.purpose, self.encoding)
    }
}

impl From<XmtpAttribute> for String {
    fn from(attr: XmtpAttribute) -> Self {
        attr.to_string()
    }
}

impl From<XmtpAttribute> for Attribute {
    fn from(attr: XmtpAttribute) -> Self {
        Self::Xmtp(attr)
    }
}

/// XMTP Key Purpose
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
pub enum XmtpKeyPurpose {
    /// XMTP Installation Keys. XMTP Installation keys are generated by the XMTP client device,
    /// used for client discovery and message encryption.
    Installation,
}

impl fmt::Display for XmtpKeyPurpose {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            XmtpKeyPurpose::Installation => write!(f, "installation"),
        }
    }
}

impl From<XmtpKeyPurpose> for String {
    fn from(purpose: XmtpKeyPurpose) -> Self {
        purpose.to_string()
    }
}

impl EthrBuilder {
    /// Build the XMTP-specific key attribute into the DID Document
    pub fn xmtp_key<V: AsRef<[u8]>>(
        &mut self,
        index: usize,
        value: V,
        key: XmtpAttribute,
    ) -> Result<(), EthrBuilderError> {
        let mut did = self.id.clone();
        did.set_fragment(Some(&format!("xmtp-{}", index)));

        log::debug!("index: {}", index);
        let mut method = VerificationMethod {
            id: did,
            controller: self.id.clone(),
            verification_type: KeyType::Ed25519VerificationKey2020,
            verification_properties: Self::encode_attribute_value(value, key.encoding)?,
        };

        method.id.set_query("meta", Some(&key.purpose.to_string()));

        match key.purpose {
            XmtpKeyPurpose::Installation => {
                self.authentication.push(method.id.clone());
            }
        };

        self.verification_method.push(method.clone());
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use crate::{
        did_registry::DidattributeChangedFilter,
        types::{test::address, tests::base_attr_changed},
    };
    use ethers::types::U256;

    use super::*;

    #[test]
    fn test_keys() {
        let identity = address("0x7e575682a8e450e33eb0493f9972821ae333cd7f");
        let attributes = vec![DidattributeChangedFilter {
            name: *b"xmtp/installation/hex           ",
            value: b"02b97c30de767f084ce3080168ee293053ba33b235d7116a3263d29f1450936b71".into(),
            ..base_attr_changed(identity, None)
        }];

        let mut builder = EthrBuilder::default();
        builder.public_key(&identity).unwrap();
        builder.now(U256::zero());

        for attr in attributes {
            builder.attribute_event(attr).unwrap()
        }

        let doc = builder.build().unwrap();

        assert_eq!(doc.verification_method[1].id.fragment().unwrap(), "xmtp-0");
        assert_eq!(
            doc.verification_method[1].id.query().unwrap(),
            "meta=installation"
        );
        assert_eq!(doc.verification_method.len(), 2);

        assert_eq!(doc.authentication[0], doc.verification_method[1].id);
    }

    #[test]
    fn test_keys_invalidity() {
        let identity = address("0x7e575682a8e450e33eb0493f9972821ae333cd7f");
        let attributes = vec![DidattributeChangedFilter {
            name: *b"xmtp/installation/hex           ",
            value: b"02b97c30de767f084ce3080168ee293053ba33b235d7116a3263d29f1450936b71".into(),
            ..base_attr_changed(identity, Some(50))
        }];

        let mut builder = EthrBuilder::default();
        builder.public_key(&identity).unwrap();
        builder.now(U256::from(100));

        for attr in attributes {
            builder.attribute_event(attr).unwrap()
        }

        assert_eq!(builder.xmtp_count, 1);

        let doc = builder.build().unwrap();
        println!("{}", serde_json::to_string_pretty(&doc).unwrap());
        assert_eq!(doc.verification_method.len(), 1);
        assert_eq!(doc.authentication.len(), 0);
    }
}
